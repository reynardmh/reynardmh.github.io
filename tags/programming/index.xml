<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programming on hilman.io</title>
    <link>http://hilman.io/tags/programming/</link>
    <description>Recent content in Programming on hilman.io</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Reynard Hilman</copyright>
    <lastBuildDate>Sun, 13 Sep 2015 23:41:00 -0400</lastBuildDate>
    <atom:link href="http://hilman.io/tags/programming/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Comparing ancestry and closure_tree for your nested data structure</title>
      <link>http://hilman.io/blog/2015/09/comparing-ancestry-and-closure_tree/</link>
      <pubDate>Sun, 13 Sep 2015 23:41:00 -0400</pubDate>
      
      <guid>http://hilman.io/blog/2015/09/comparing-ancestry-and-closure_tree/</guid>
      <description>

&lt;p&gt;When it comes to implementing &lt;a href=&#34;https://www.ruby-toolbox.com/categories/Active_Record_Nesting&#34; target=&#34;_blank&#34;&gt;ActiveRecord nesting&lt;/a&gt;, there are a few popular implementations. In this post I will look closer at how &lt;a href=&#34;https://github.com/stefankroes/ancestry&#34; target=&#34;_blank&#34;&gt;Ancestry&lt;/a&gt; and &lt;a href=&#34;http://mceachen.github.io/closure_tree/&#34; target=&#34;_blank&#34;&gt;Closure tree&lt;/a&gt; work and what the pros and cons are.&lt;/p&gt;

&lt;h2 id=&#34;how-ancestry-works:628b029b0b3197d22f44409ae77e0f7d&#34;&gt;How ancestry works&lt;/h2&gt;

&lt;p&gt;Ancestry works by adding one column (by default named &amp;ldquo;ancestry&amp;rdquo;) that replaces the parent_id. Instead of just storing the parent_id, ancestry stores the whole ancestry path to the parent_id.&lt;/p&gt;

&lt;p&gt;For example if you have this tree structure.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(id: 1) Page 1
(id: 2)   Page 1.1
(id: 3)   Page 1.2
(id: 4)     Page 1.2.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is how it looks in the database&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+----+------------+----------+
| id | name       | ancestry |
+----+------------+----------+
|  1 | Page 1     | NULL     |
|  2 | Page 1.1   | 1        |
|  3 | Page 1.2   | 1        |
|  4 | Page 1.2.1 | 1/3      |
+----+------------+----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This way you can always find the children of a node by selecting &lt;code&gt;where ancestry = &amp;quot;{self.ancestry}/{self.id}&amp;quot;&lt;/code&gt;. And you can find all the descendants of a node by selecting &lt;code&gt;where
(ancestry = &amp;quot;{self.ancestry}/{self.id}&amp;quot; OR ancestry LIKE &amp;quot;{self.ancestry}/{self.id}/%&amp;quot;)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;To select all ancestors of a node, you just select &lt;code&gt;where id IN (ancestry_ids)&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;how-closure-tree-works:628b029b0b3197d22f44409ae77e0f7d&#34;&gt;How closure_tree works&lt;/h2&gt;

&lt;p&gt;Closure tree is a little more complicated than Ancestry. In addition to using the regular parent_id on your model, it also uses a separate hierarchy table.&lt;/p&gt;

&lt;p&gt;So if you have a Page model, you also need to have page_hierarchies table that has the following columns: ancestor_id, descendant_id, and generations.&lt;/p&gt;

&lt;p&gt;What are all these columns for? Let&amp;rsquo;s figure that out by observing how it populates the table. Using the same structure&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(id: 1) Page 1
(id: 2)   Page 1.1
(id: 3)   Page 1.2
(id: 4)     Page 1.2.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;closure_tree created the following rows in the hierarchy table:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+-------------+---------------+-------------+
| ancestor_id | descendant_id | generations |
+-------------+---------------+-------------+
|           1 |             1 |           0 |
|           1 |             2 |           1 |
|           1 |             3 |           1 |
|           1 |             4 |           2 |
|           2 |             2 |           0 |
|           3 |             3 |           0 |
|           3 |             4 |           1 |
|           4 |             4 |           0 |
+-------------+---------------+-------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It basically creates a single row for every descendant an ancestor has, and another row where the ancestor_id = descendant_id.&lt;/p&gt;

&lt;p&gt;Because &amp;ldquo;Page 1&amp;rdquo; is the root ancestor, there is one row for itself and 3 more rows for each node under &amp;ldquo;Page 1&amp;rdquo;. This way you can find all the descendants by selecting where &lt;code&gt;ancestor_id = self.id&lt;/code&gt; and joining with the main node table so you can do this in 1 select query. In the same way, you can find all the ancestor by selecting &lt;code&gt;where descendant_id = self.id&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The generations column indicates how many generations the relation between the ancestor_id and the descendant_id. For example (id: 1) is the direct parent of (id: 2), therefore their relation has generations:1. All rows where ancestor_id = descendant_id has generations:0.&lt;/p&gt;

&lt;h2 id=&#34;benchmark:628b029b0b3197d22f44409ae77e0f7d&#34;&gt;Benchmark&lt;/h2&gt;

&lt;h3 id=&#34;write:628b029b0b3197d22f44409ae77e0f7d&#34;&gt;Write&lt;/h3&gt;

&lt;p&gt;Populating deeply nested data (25 level deep)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Ancestry: 0.083076
Closure tree: 0.215164
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Populating shallow nested data&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Ancestry: 0.192071
Closure tree: 0.490023
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So in general closure_tree is more than 2 times slower at inserting data, because it has to do a lot more inserts to the hierarchy table.&lt;/p&gt;

&lt;h3 id=&#34;read:628b029b0b3197d22f44409ae77e0f7d&#34;&gt;Read&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s see how they do for selecting the ancestors and descendants&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                              user     system      total        real
ancestry.ancestors        0.000000   0.000000   0.000000 (  0.009915)
closure_tree.ancestors    0.020000   0.010000   0.030000 (  0.030023)

                              user     system      total        real
ancestry.descendants      0.010000   0.000000   0.010000 (  0.014332)
closure_tree.descendants  0.020000   0.010000   0.030000 (  0.021242)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The select benchmark might be really dependent on db caching. Assuming the same db and caching mechanism, ancestry wins with a pretty good margin.&lt;/p&gt;

&lt;h3 id=&#34;update:628b029b0b3197d22f44409ae77e0f7d&#34;&gt;Update&lt;/h3&gt;

&lt;p&gt;Because each node stores information about its ancestors, moving a node means we need to update all the descendants to reflect the new ancestry tree.&lt;/p&gt;

&lt;p&gt;The following benchmark move a root node with 14 nodes under it, and then move it back to root.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                              user     system      total        real
ancestry - move node      0.380000   0.130000   0.510000 (  0.639941)
closure_tree - move node  0.780000   0.150000   0.930000 (  1.802662)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Moving a root node with 25 nodes under it, and then move it back to root.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                              user     system      total        real
ancestry - move node      0.510000   0.170000   0.680000 (  0.799853)
closure_tree - move node  1.260000   0.180000   1.440000 (  2.733766)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary:628b029b0b3197d22f44409ae77e0f7d&#34;&gt;Summary&lt;/h2&gt;

&lt;h3 id=&#34;ancestry-pros:628b029b0b3197d22f44409ae77e0f7d&#34;&gt;Ancestry Pros:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Simpler data structure to understand&lt;/li&gt;
&lt;li&gt;In general faster (inserting, selecting and moving nodes around)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ancestry-cons:628b029b0b3197d22f44409ae77e0f7d&#34;&gt;Ancestry Cons:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Because the ancestry column is a varchar(255), there is a limitation on the tree depth (depending on what type of primary key you use). An INT in MySql has a max value of 2147483647 (10 digits), which means that you are limited to &lt;sup&gt;255&lt;/sup&gt;&amp;frasl;&lt;sub&gt;11&lt;/sub&gt; = 23 ancestors. You have to make sure that your application does not allow creating more nested data than this limit.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;closure-tree-pros:628b029b0b3197d22f44409ae77e0f7d&#34;&gt;closure_tree Pros:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;If you have a huge existing nested data (using parent_id), you don&amp;rsquo;t have to run migration to add a new column (which could take a long time).&lt;/li&gt;
&lt;li&gt;Unlimited level of nesting&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;closure-tree-cons:628b029b0b3197d22f44409ae77e0f7d&#34;&gt;closure_tree Cons:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Slower&lt;/li&gt;
&lt;li&gt;Not ideal if you need to move nodes often&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The source code for this &lt;a href=&#34;https://github.com/reynardmh/nested_model_benchmark&#34;&gt;benchmark&lt;/a&gt; is available on github.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>What you need to know about gitignore pattern</title>
      <link>http://hilman.io/blog/2015/09/what-you-need-to-know-about-gitignore/</link>
      <pubDate>Mon, 07 Sep 2015 20:15:26 -0400</pubDate>
      
      <guid>http://hilman.io/blog/2015/09/what-you-need-to-know-about-gitignore/</guid>
      <description>

&lt;p&gt;After using git for a long time, I thought I knew the basic of gitignore well enough, until I ran into problem with my files not getting committed. There were some basic gitignore patterns that I wasn&amp;rsquo;t aware of.&lt;/p&gt;

&lt;h2 id=&#34;the-problem-i-ran-into:c5cbae0bff61d1461796445415115d58&#34;&gt;The problem I ran into&lt;/h2&gt;

&lt;p&gt;I had just moved a directory to another directory.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/some/path/doc         # old location
/some/path/nested/doc  # new location
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Git detects that I’m deleting a bunch of files, but it doesn’t show that I’m adding any new files. I thought git just doesn’t immediately detect the new files. So I committed the changes hoping that now git will detect the new files. It still doesn’t. I wonder what happens if I just move the directory back to its original location. Technically it should revert my changes, right? But moving it back doesn’t help either, git still does not detect that there is any changes in my repository.&lt;/p&gt;

&lt;p&gt;I start to suspect gitignore settings. I noticed that at some point someone added this line in gitignore&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;doc
tmp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That looks suspicious. I thought that just means to ignore any directory named &amp;ldquo;doc&amp;rdquo; in the root of the project. But maybe I&amp;rsquo;m wrong. So I commented out that line to see if it did anything. And it did detect that there were changes to be committed.&lt;/p&gt;

&lt;p&gt;When you specify just a word without leading or trailing slash, it will match any directory or files with that name anywhere in your project. So having “doc” in .gitignore, means:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# .gitignore
doc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will ignore all of these:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/doc # directory
/doc # file
/some/path/doc # directory
/some/path/doc # file
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;what-if-you-just-want-to-ignore-the-directory-at-the-root-level:c5cbae0bff61d1461796445415115d58&#34;&gt;What if you just want to ignore the directory at the root level?&lt;/h2&gt;

&lt;p&gt;The correct syntax for that is to put leading and trailing slash:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# .gitignore
/doc/
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# will ignore
/doc # directory

# will NOT ignore
/doc         # file
/some/doc    # directory
/another/doc # file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Why the need for trailing slash? If you just put leading slash, it will still ignore the doc directory at the root level, but it will also ignore a file named “doc” at the root level, if you have a file instead of a directory named “doc” at the root level.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# .gitignore
/doc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will ignore&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/doc # directory
/doc # file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So what if we only include trailing slash?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# .gitignore
doc/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it will ignore all directory named “doc” anywhere in your project, but it will not ignore any files named “doc”&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# will ignore:
/doc # directory
/some/path/doc # directory

# will NOT ignore:
/another/path/doc # file
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary:c5cbae0bff61d1461796445415115d58&#34;&gt;Summary&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;To ignore just directories, add a slash at the end of the pattern. Otherwise it will ignore both files and directories.&lt;/li&gt;
&lt;li&gt;To ignore just files/directories at the root, add a slash at the beginning of the pattern. Otherwise it will ignore files/directories anywhere in your project.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you&amp;rsquo;re curious, check out a more detailed documentation about &lt;a href=&#34;http://git-scm.com/docs/gitignore&#34;&gt;gitignore patterns&lt;/a&gt;. These 2 basic patterns seem like a must know for most git users, so you don&amp;rsquo;t accidentally ignore more stuff than you intended to.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>