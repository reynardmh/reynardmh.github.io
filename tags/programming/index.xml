<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programming on hilman.io</title>
    <link>http://hilman.io/tags/programming/</link>
    <description>Recent content in Programming on hilman.io</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Reynard Hilman</copyright>
    <lastBuildDate>Sat, 23 Jan 2016 13:56:39 -0500</lastBuildDate>
    <atom:link href="http://hilman.io/tags/programming/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Stop using backtick to run shell command in Ruby</title>
      <link>http://hilman.io/blog/2016/01/stop-using-backtick-to-run-shell-command-in-ruby/</link>
      <pubDate>Sat, 23 Jan 2016 13:56:39 -0500</pubDate>
      
      <guid>http://hilman.io/blog/2016/01/stop-using-backtick-to-run-shell-command-in-ruby/</guid>
      <description>

&lt;p&gt;It&amp;rsquo;s all too common to find the use of backtick to run shell command from Ruby. It&amp;rsquo;s fine when you just run a command that doesn&amp;rsquo;t take any user input. But when you start passing input from untrusted source, that&amp;rsquo;s when the trouble begins.&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;&lt;span class=&#34;n&#34;&gt;output&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;sb&#34;&gt;`echo &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;#{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;user_input&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The problem is that this is vulnerable to command injection. Consider this user input.&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;&lt;span class=&#34;n&#34;&gt;user_input&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;quot;hello; rm -rf *&amp;quot;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;output&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;sb&#34;&gt;`echo &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;#{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;user_input&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This will echo &amp;lsquo;hello&amp;rsquo;, and then remove all files from the current directory. Not so nice eh? Of course you can build your own input sanitizer that makes sure command injection will not happen.&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;&lt;span class=&#34;n&#34;&gt;output&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;sb&#34;&gt;`echo &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;#{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;input_sanitizer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;user_input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;But the problem is that you have to make sure that every developer never forgets to use the sanitizer. I can&amp;rsquo;t trust myself to never forget to do this, much less trusting that every developer will never forget.&lt;/p&gt;

&lt;h2 id=&#34;so-what-are-the-alternatives:b06cb31d74ab342655d014b2186f0a0a&#34;&gt;So what are the alternatives?&lt;/h2&gt;

&lt;p&gt;There are a few Ruby built in methods that automatically handle this.&lt;/p&gt;

&lt;h3 id=&#34;kernel-system:b06cb31d74ab342655d014b2186f0a0a&#34;&gt;Kernel.system&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://ruby-doc.org/core-2.3.0/Kernel.html#method-i-system&#34; target=&#34;_blank&#34;&gt;Kernel.system&lt;/a&gt; runs the command and returns true if the command was successful (has 0 exit status). If you pass user_input as separate arguments, it will safely escape it.&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;&lt;span class=&#34;nb&#34;&gt;system&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;quot;echo&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;user_input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Of course you can still pass the user_input interpolated in the command string and still make your code un-safe.&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;&lt;span class=&#34;nb&#34;&gt;system&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;quot;echo &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;#{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;user_input&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# Don&amp;#39;t do this please !!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;But a static code analysis tool like &lt;a href=&#34;https://docs.codeclimate.com/docs/brakeman&#34; target=&#34;_blank&#34;&gt;codeclimate brakeman&lt;/a&gt; will catch this and warn you about the vulnerability.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ codeclimate analyze -e brakeman myapp.rb

&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; myapp.rb &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; issue&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;
1-: Possible &lt;span class=&#34;nb&#34;&gt;command&lt;/span&gt; injection &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;brakeman&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;If you notice though, &lt;code&gt;Kernel.system&lt;/code&gt; does not return the output of the command the way backtick does. This leads us to the next alternative, Open3.&lt;/p&gt;

&lt;h3 id=&#34;open3-module:b06cb31d74ab342655d014b2186f0a0a&#34;&gt;Open3 module&lt;/h3&gt;

&lt;p&gt;From &lt;a href=&#34;http://ruby-doc.org/stdlib-2.3.0/libdoc/open3/rdoc/Open3.html&#34; target=&#34;_blank&#34;&gt;Open3 documentation&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Open3 grants you access to stdin, stdout, stderr and a thread to wait for the child process when running another program.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;There are many methods provided by Open3 which you can read in the documentation. For the example we&amp;rsquo;ve been using, we can use &lt;code&gt;Open3.capture2&lt;/code&gt; to replace using backtick to run a command and capture the output.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;&lt;span class=&#34;n&#34;&gt;user_input&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;quot;hello; rm -rf *&amp;quot;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;output&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;status&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;Open3&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;capture2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;echo&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;user_input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;nb&#34;&gt;puts&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;output&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;# -&amp;gt; &amp;quot;hello; rm -rf *\n&amp;quot;&lt;/span&gt;
&lt;span class=&#34;nb&#34;&gt;puts&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;# 123 or the process id&lt;/span&gt;
&lt;span class=&#34;nb&#34;&gt;puts&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;exitstatus&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# 0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h3 id=&#34;conclusion:b06cb31d74ab342655d014b2186f0a0a&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s OK to use backtick when you don&amp;rsquo;t have any user input. But when you start passing untrusted input it&amp;rsquo;s best to always use &lt;code&gt;system&lt;/code&gt; or &lt;code&gt;Open3&lt;/code&gt; to sanitize the input. It&amp;rsquo;s also strongly recommended to use a static code analysis tool like &lt;a href=&#34;https://docs.codeclimate.com/docs/brakeman&#34; target=&#34;_blank&#34;&gt;codeclimate brakeman&lt;/a&gt; to make sure no developer in your team forget to follow this best practice.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Comparing ancestry and closure_tree for your nested data structure</title>
      <link>http://hilman.io/blog/2015/09/comparing-ancestry-and-closure_tree/</link>
      <pubDate>Sun, 13 Sep 2015 23:41:00 -0400</pubDate>
      
      <guid>http://hilman.io/blog/2015/09/comparing-ancestry-and-closure_tree/</guid>
      <description>

&lt;p&gt;When it comes to implementing &lt;a href=&#34;https://www.ruby-toolbox.com/categories/Active_Record_Nesting&#34; target=&#34;_blank&#34;&gt;ActiveRecord nesting&lt;/a&gt;, there are a few popular implementations. In this post I will look closer at how &lt;a href=&#34;https://github.com/stefankroes/ancestry&#34; target=&#34;_blank&#34;&gt;Ancestry&lt;/a&gt; and &lt;a href=&#34;http://mceachen.github.io/closure_tree/&#34; target=&#34;_blank&#34;&gt;Closure tree&lt;/a&gt; work and what the pros and cons are.&lt;/p&gt;

&lt;h2 id=&#34;how-ancestry-works:628b029b0b3197d22f44409ae77e0f7d&#34;&gt;How ancestry works&lt;/h2&gt;

&lt;p&gt;Ancestry works by adding one column (by default named &amp;ldquo;ancestry&amp;rdquo;) that replaces the parent_id. Instead of just storing the parent_id, ancestry stores the whole ancestry path to the parent_id.&lt;/p&gt;

&lt;p&gt;For example if you have this tree structure.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(id: 1) Page 1
(id: 2)   Page 1.1
(id: 3)   Page 1.2
(id: 4)     Page 1.2.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is how it looks in the database&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+----+------------+----------+
| id | name       | ancestry |
+----+------------+----------+
|  1 | Page 1     | NULL     |
|  2 | Page 1.1   | 1        |
|  3 | Page 1.2   | 1        |
|  4 | Page 1.2.1 | 1/3      |
+----+------------+----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This way you can always find the children of a node by selecting &lt;code&gt;where ancestry = &amp;quot;{self.ancestry}/{self.id}&amp;quot;&lt;/code&gt;. And you can find all the descendants of a node by selecting &lt;code&gt;where
(ancestry = &amp;quot;{self.ancestry}/{self.id}&amp;quot; OR ancestry LIKE &amp;quot;{self.ancestry}/{self.id}/%&amp;quot;)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;To select all ancestors of a node, you just select &lt;code&gt;where id IN (ancestry_ids)&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;how-closure-tree-works:628b029b0b3197d22f44409ae77e0f7d&#34;&gt;How closure_tree works&lt;/h2&gt;

&lt;p&gt;Closure tree is a little more complicated than Ancestry. In addition to using the regular parent_id on your model, it also uses a separate hierarchy table.&lt;/p&gt;

&lt;p&gt;So if you have a Page model, you also need to have page_hierarchies table that has the following columns: ancestor_id, descendant_id, and generations.&lt;/p&gt;

&lt;p&gt;What are all these columns for? Let&amp;rsquo;s figure that out by observing how it populates the table. Using the same structure&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(id: 1) Page 1
(id: 2)   Page 1.1
(id: 3)   Page 1.2
(id: 4)     Page 1.2.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;closure_tree created the following rows in the hierarchy table:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+-------------+---------------+-------------+
| ancestor_id | descendant_id | generations |
+-------------+---------------+-------------+
|           1 |             1 |           0 |
|           1 |             2 |           1 |
|           1 |             3 |           1 |
|           1 |             4 |           2 |
|           2 |             2 |           0 |
|           3 |             3 |           0 |
|           3 |             4 |           1 |
|           4 |             4 |           0 |
+-------------+---------------+-------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It basically creates a single row for every descendant an ancestor has, and another row where the ancestor_id = descendant_id.&lt;/p&gt;

&lt;p&gt;Because &amp;ldquo;Page 1&amp;rdquo; is the root ancestor, there is one row for itself and 3 more rows for each node under &amp;ldquo;Page 1&amp;rdquo;. This way you can find all the descendants by selecting where &lt;code&gt;ancestor_id = self.id&lt;/code&gt; and joining with the main node table so you can do this in 1 select query. In the same way, you can find all the ancestor by selecting &lt;code&gt;where descendant_id = self.id&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The generations column indicates how many generations the relation between the ancestor_id and the descendant_id. For example (id: 1) is the direct parent of (id: 2), therefore their relation has generations:1. All rows where ancestor_id = descendant_id has generations:0.&lt;/p&gt;

&lt;h2 id=&#34;benchmark:628b029b0b3197d22f44409ae77e0f7d&#34;&gt;Benchmark&lt;/h2&gt;

&lt;h3 id=&#34;write:628b029b0b3197d22f44409ae77e0f7d&#34;&gt;Write&lt;/h3&gt;

&lt;p&gt;Populating deeply nested data (25 level deep)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Ancestry: 0.083076
Closure tree: 0.215164
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Populating shallow nested data&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Ancestry: 0.192071
Closure tree: 0.490023
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So in general closure_tree is more than 2 times slower at inserting data, because it has to do a lot more inserts to the hierarchy table.&lt;/p&gt;

&lt;h3 id=&#34;read:628b029b0b3197d22f44409ae77e0f7d&#34;&gt;Read&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s see how they do for selecting the ancestors and descendants&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                              user     system      total        real
ancestry.ancestors        0.000000   0.000000   0.000000 (  0.009915)
closure_tree.ancestors    0.020000   0.010000   0.030000 (  0.030023)

                              user     system      total        real
ancestry.descendants      0.010000   0.000000   0.010000 (  0.014332)
closure_tree.descendants  0.020000   0.010000   0.030000 (  0.021242)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The select benchmark might be really dependent on db caching. Assuming the same db and caching mechanism, ancestry wins with a pretty good margin.&lt;/p&gt;

&lt;h3 id=&#34;update:628b029b0b3197d22f44409ae77e0f7d&#34;&gt;Update&lt;/h3&gt;

&lt;p&gt;Because each node stores information about its ancestors, moving a node means we need to update all the descendants to reflect the new ancestry tree.&lt;/p&gt;

&lt;p&gt;The following benchmark move a root node with 14 nodes under it, and then move it back to root.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                              user     system      total        real
ancestry - move node      0.380000   0.130000   0.510000 (  0.639941)
closure_tree - move node  0.780000   0.150000   0.930000 (  1.802662)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Moving a root node with 25 nodes under it, and then move it back to root.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                              user     system      total        real
ancestry - move node      0.510000   0.170000   0.680000 (  0.799853)
closure_tree - move node  1.260000   0.180000   1.440000 (  2.733766)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary:628b029b0b3197d22f44409ae77e0f7d&#34;&gt;Summary&lt;/h2&gt;

&lt;h3 id=&#34;ancestry-pros:628b029b0b3197d22f44409ae77e0f7d&#34;&gt;Ancestry Pros:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Simpler data structure to understand&lt;/li&gt;
&lt;li&gt;In general faster (inserting, selecting and moving nodes around)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ancestry-cons:628b029b0b3197d22f44409ae77e0f7d&#34;&gt;Ancestry Cons:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Because the ancestry column is a varchar(255), there is a limitation on the tree depth (depending on what type of primary key you use). An INT in MySql has a max value of 2147483647 (10 digits), which means that you are limited to &lt;sup&gt;255&lt;/sup&gt;&amp;frasl;&lt;sub&gt;11&lt;/sub&gt; = 23 ancestors. You have to make sure that your application does not allow creating more nested data than this limit.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;closure-tree-pros:628b029b0b3197d22f44409ae77e0f7d&#34;&gt;closure_tree Pros:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;If you have a huge existing nested data (using parent_id), you don&amp;rsquo;t have to run migration to add a new column (which could take a long time).&lt;/li&gt;
&lt;li&gt;Unlimited level of nesting&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;closure-tree-cons:628b029b0b3197d22f44409ae77e0f7d&#34;&gt;closure_tree Cons:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Slower&lt;/li&gt;
&lt;li&gt;Not ideal if you need to move nodes often&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The source code for this &lt;a href=&#34;https://github.com/reynardmh/nested_model_benchmark&#34;&gt;benchmark&lt;/a&gt; is available on github.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>What you need to know about gitignore pattern</title>
      <link>http://hilman.io/blog/2015/09/what-you-need-to-know-about-gitignore/</link>
      <pubDate>Mon, 07 Sep 2015 20:15:26 -0400</pubDate>
      
      <guid>http://hilman.io/blog/2015/09/what-you-need-to-know-about-gitignore/</guid>
      <description>

&lt;p&gt;After using git for a long time, I thought I knew the basic of gitignore well enough, until I ran into problem with my files not getting committed. There were some basic gitignore patterns that most git users are just not aware of. So some of us might have put something on gitignore without realizing that it does ignore a lot more stuff than we intend.&lt;/p&gt;

&lt;h2 id=&#34;the-problem-i-ran-into:c5cbae0bff61d1461796445415115d58&#34;&gt;The problem I ran into&lt;/h2&gt;

&lt;p&gt;I had just moved a directory to another directory.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/some/path/doc         # old location
/some/path/nested/doc  # new location
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Git detects that I’m deleting a bunch of files, but it doesn’t show that I’m adding any new files. I thought git just doesn’t immediately detect the new files. So I committed the changes hoping that now git will detect the new files. It still doesn’t. I wonder what happens if I just move the directory back to its original location. Technically it should revert my changes, right? But moving it back doesn’t help either, git still does not detect that there is any changes in my repository.&lt;/p&gt;

&lt;p&gt;I start to suspect gitignore settings. I noticed that at some point someone added this line in gitignore&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;doc
tmp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That looks suspicious. I thought that just means to ignore any directory named &amp;ldquo;doc&amp;rdquo; in the root of the project. But maybe I&amp;rsquo;m wrong. So I commented out that line to see if it did anything. And it did detect that there were changes to be committed.&lt;/p&gt;

&lt;p&gt;When you specify just a word without leading or trailing slash, it will match any directory or files with that name anywhere in your project. So having “doc” in .gitignore, means:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# .gitignore
doc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will ignore all of these:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/doc # directory
/doc # file
/some/path/doc # directory
/some/path/doc # file
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;what-if-you-just-want-to-ignore-the-directory-at-the-root-level:c5cbae0bff61d1461796445415115d58&#34;&gt;What if you just want to ignore the directory at the root level?&lt;/h2&gt;

&lt;p&gt;The correct syntax for that is to put leading and trailing slash:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# .gitignore
/doc/
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# will ignore
/doc # directory

# will NOT ignore
/doc         # file
/some/doc    # directory
/another/doc # file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Why the need for trailing slash? If you just put leading slash, it will still ignore the doc directory at the root level, but it will also ignore a file named “doc” at the root level, if you have a file instead of a directory named “doc” at the root level.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# .gitignore
/doc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will ignore&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/doc # directory
/doc # file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So what if we only include trailing slash?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# .gitignore
doc/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it will ignore all directory named “doc” anywhere in your project, but it will not ignore any files named “doc”&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# will ignore:
/doc # directory
/some/path/doc # directory

# will NOT ignore:
/another/path/doc # file
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary:c5cbae0bff61d1461796445415115d58&#34;&gt;Summary&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;To ignore just directories, add a slash at the end of the pattern. Otherwise it will ignore both files and directories.&lt;/li&gt;
&lt;li&gt;To ignore just files/directories at the root, add a slash at the beginning of the pattern. Otherwise it will ignore files/directories anywhere in your project.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you&amp;rsquo;re curious, check out a more detailed documentation about &lt;a href=&#34;http://git-scm.com/docs/gitignore&#34;&gt;gitignore patterns&lt;/a&gt;. These 2 basic patterns seem like a must know for most git users, so you don&amp;rsquo;t accidentally ignore more stuff than you intended to.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>